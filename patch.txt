import re
from bs4 import BeautifulSoup
from typing import Set, List

URL_RE = re.compile(
    r'(?:(?:https?|ftp):\/\/)'          # scheme
    r'[^\s<>\]]+'                       # host/path (simple)
    , re.IGNORECASE
)

def extract_urls_from_html(html: str) -> List[str]:
    """Parse HTML and return all hrefs from <a> tags and also fallback to regex on text."""
    urls = []
    if not html:
        return urls
    soup = BeautifulSoup(html, "html.parser")
    for a in soup.find_all("a", href=True):
        urls.append(a["href"])
    # also fallback: some links might be embedded text without <a>
    text = soup.get_text(separator=" ")
    urls += URL_RE.findall(text)
    return list(dict.fromkeys(urls))  # dedupe preserving order

def extract_urls_from_text(text: str) -> List[str]:
    if not text:
        return []
    return list(dict.fromkeys(URL_RE.findall(text)))

def extract_all_urls_from_issue(issue_json: dict) -> List[str]:
    """Return deduped list of URLs found across the issue JSON."""
    found = []
    def add_many(items):
        for u in items:
            if u not in found:
                found.append(u)

    # 1) Issuelinks (structured)
    for il in issue_json.get("fields", {}).get("issuelinks", []):
        # issuelinks may have outwardIssue/inwardIssue or be a simple dict
        for side in ("inwardIssue", "outwardIssue", "outwardIssue", "inwardIssue"):
            if side in il and isinstance(il[side], dict):
                key = il[side].get("key")
                if key:
                    # construct a canonical Jira issue URL (customize base_url)
                    base_url = "https://your-jira-instance.atlassian.net/browse/"
                    add_many([base_url + key])
        # sometimes there is a 'self' url or 'id' inside the link
        if "self" in il:
            add_many([il["self"]])

    # 2) Attachments
    for a in issue_json.get("fields", {}).get("attachment", []):
        if "content" in a:
            add_many([a["content"]])
        if "self" in a:
            add_many([a["self"]])

    # 3) Links from renderedFields if available (preferred)
    rendered = issue_json.get("renderedFields", {})
    if rendered:
        add_many(extract_urls_from_html(rendered.get("description", "")))
        # comments
        comments = rendered.get("comment", {}).get("comments", [])
        for c in comments:
            add_many(extract_urls_from_html(c.get("body", "")))

    # 4) Fallback: parse plain text fields (description, comments, any custom text fields)
    fields = issue_json.get("fields", {})
    add_many(extract_urls_from_text(fields.get("description", "") or ""))
    # comments in fields
    for c in fields.get("comment", {}).get("comments", []):
        add_many(extract_urls_from_text(c.get("body", "") or ""))
    # iterate over all fields: if value is str, run regex â€” helpful for unknown customfields
    for k, v in fields.items():
        if isinstance(v, str):
            add_many(extract_urls_from_text(v))

    return found
